---
title: "正式-实模式print"
date: 2022-06-15T17:07:26+08:00
lastmod: 2022-05-11T20:02:48+08:00
categories: ["docs"]
tags: ["docs"]
author: "lyr"
draft: false
images: ["https://api.mtyqx.cn/api/random.php"]

---



[参考学习教程](https://www.bilibili.com/video/BV1WS4y1V7gK/?spm_id_from=333.788&vd_source=5680f9cc1e793f7b70191c94d5552ecb)

[参考的开源项目 onix](https://github.com/StevenBaby/onix)



```asm
[org 0x7c00]

; 设置屏幕模式为文本模式，清除屏幕
mov ax, 3
int 0x10

; 初始化段寄存器
mov ax, 0
mov ds, ax
mov es, ax
mov ss, ax
mov sp, 0x7c00
; 800 是文本显示器呢次
; mov ax,0xb800 
;----- mov byte 这种方式不够优雅打印字符的话
;mov ds,ax
;mov byte [0],'H'
;mov byte [2],'I'
xchg bx,bx; 这个指令没用，自己和自己交换，只是个断点，可删除
mov si,booting
call print

jmp $

print:
    mov ah,0x0e
.next:
    mov al,[si]
    cmp al,0 ; al和 0 比较，如果 等于0，就 done,返回，否则就继续执行next指令，用来打印字符串
    jz .done 
    int 0x10
    inc si ; 将 si指向下一个字符，incr
    jmp .next    
.done:
    ret 
booting:
    db "booting",10,13,0




times 510 - ($-$$) db 0
 ; 为什么是 510 不是512呢？ 因为最后2个字要填充魔数 ，0xaa55
; DW 0XAA55    

db 0x55,0xaa






```


这个教程讲的不错， 这里面实现了类似于自定义函数的功能 


```asm
mov si,booting ; booting 地址 si是一个指针，指向 booting字符串的内容地址 
call print ; 调用封装好的指令



print:
    mov ah,0x0e
.next:
    mov al,[si]
    cmp al,0 ; al和 0 比较，如果 等于0，就 done,返回，否则就继续执行next指令，用来打印字符串
    jz .done 
    int 0x10
    inc si ; 将 si指向下一个字符，incr
    jmp .next    
.done:
    ret 
booting:
    db "booting",10,13,0



```



## 硬盘读取


硬盘控制端口

| Primary 通道            | Secondary 通道 | in 操作      | out 操作     |
| ----------------------- | -------------- | ------------ | ------------ |
| 0x1F0                   | 0x170          | Data         | Data         |
| 0x1F1                   | 0x171          | Error        | Features     |
| 0x1F2                   | 0x172          | Sector count | Sector count |
| 0x1F3                   | 0x173          | LBA low      | LBA low      |
| 0x1F4                   | 0x174          | LBA mid      | LBA mid      |
| 0x1F5                   | 0x175          | LBA high     | LBA high     |
| 0x1F6                   | 0x176          | Device       | Device       |
| 0x1F7                   | 0x177          | Status       | Command      |

- 0x1F0：16bit 端口，用于读写数据
- 0x1F1：检测前一个指令的错误
- 0x1F2：读写扇区的数量
- 0x1F3：起始扇区的 0 ~ 7 位
- 0x1F4：起始扇区的 8 ~ 15 位
- 0x1F5：起始扇区的 16 ~ 23 位
- 0x1F6:
    - 0 ~ 3：起始扇区的 24 ~ 27 位
    - 4: 0 主盘, 1 从片
    - 6: 0 CHS, 1 LBA
    - 5 ~ 7：固定为1
- 0x1F7: out
    - 0xEC: 识别硬盘
    - 0x20: 读硬盘
    - 0x30: 写硬盘
- 0x1F7: in / 8bit
    - 0 ERR
    - 3 DRQ 数据准备完毕
    - 7 BSY 硬盘繁忙

## 参考文献

- <https://www.youtube.com/watch?v=oEORcCQ62nQ>
- <https://wiki.osdev.org/ATA_PIO_Mode>
- <https://bochs.sourceforge.io/techspec/PORTS.LST>
- <https://www.techtarget.com/searchstorage/definition/IDE>


## 内核加载器实现


主引导扇区就是用来加载内核的， 我们要实现读取内核加载器，并且执行


