---
title: "寄存器"
date: 2022-06-11T20:57:21+08:00
lastmod: 2022-05-11T20:02:48+08:00
categories: ["docs"]
tags: ["docs"]
author: "lyr"
draft: false
images: ["https://api.mtyqx.cn/api/random.php"]

---

## 寄存器


8086中， 8个16位的通用寄存器: AX,BX,CX,DX,SI,BP,SP

还可以把这个 ax拆成两个8位寄存器来用

寄存器只是暂存数据的中间运算结果


## 代码段和数据段的概念

代码段和数据段是一个逻辑概念，


| 高位寄存器 | 低位  | 寄存器 |
| :--------: | :---: | :----: |
|     AH     |  AL   |   AX   |
|     BH     |  BL   |   BX   |



CS 指向代码开始位置，DS指向数据段的开始位置

8086 分段机制：
我们可以通过改变CS寄存器的数字、去改变想要推进的程序
也就是说 cs 存放的就是程序的当前指令地址

[参考文章](https://www.cnblogs.com/xiangtingshen/p/11368623.html)


端+偏移量的方法 可以灵活加载多段程序

也就是说我们的代码看到的都是逻辑地址，我们没办法和硬件打交道，只有操作系统那个才是物理地址【真实的地址】







## 计算机启动过程


POST (power on self testing)

计算机会加电自检

[bios 和 uefi区别是什么？bios会被uefi取代吗？](https://zhuanlan.zhihu.com/p/436122944)

efi 和uefi其实都属于 bios，bios是固化在主板上的 （所有的操作系统都有个bootloader 的加载过程）

bios把程序拉入内存， 读取硬盘 的程序，然后 CPU指向程序的执行位置！

cpu设定是只能运行内存中的程序

在操作系统运行前，我们的bios接管这台机器（问题：bios是谁加载的，它被加载到哪里？)

bios 是硬件本身强制加载的，开机，CPU就被硬件强制去执行bios程序



```asm
ORG 07C00H            	;告诉编译器程序被加载的地址为0x7c00
MOV AX, CS
MOV DS, AX
MOV ES, AX
CALL SHOW
JMP $
SHOW:
    MOV AX, MESSAGE
    MOV BP, AX
    MOV CX, 16
    MOV AX, 01301H        	;AH = 13H AL = 01H
    MOV BX, 000CH         	;页号为0 BH = 0 红底黑字 BL = 0CH
    MOV DL, 0
    INT 10H
    RET
MESSAGE:  DB "HELLO, OS WORLD!"
    TIMES 510 - ($ - $$) DB 0	;剩下的字节全部使用0填充(填充，补足 512字节)

    DW 0XAA55             	;

```


```bash
hexdump.exe  .\boot.bin | grep aa55

# 这里你可以看到 boot.bin 的文件结构，包括后面那个 aa55 

```


| 起始  | 结束  | 大小             | 用途                                                                                                                                           |
| :---- | :---- | :--------------- | :--------------------------------------------------------------------------------------------------------------------------------------------- |
| FFFF0 | FFFFF | 16B              | BIOS的入口地址，此地址也属于BIOS代码，同样属于顶部的640KB字节，只是为了强调其入口地址才单独贴出来的。此处16字节的内容是跳转指令`jmp f000:e05b` |
| F0000 | FFFEF | 64kb-16b         | 系统BIOS范围是F0000～FFFFF共64B，为说明入口地址，将最上面的16字节从此处去掉，所以此处的终止地址是0xFFFFEF                                      |
| C8000 | EFFFF | 160KB            | 映射硬件适配器的ROM或内存映射式I/O                                                                                                             |
| C0000 | C7FFF | 32KB             | 显示适配器BIOS                                                                                                                                 |
| B8000 | BFFFF | 32KB             | 用于文本模式显示适配器                                                                                                                         |
| B0000 | B7FFF | 32KB             | 用于黑白显示适配器                                                                                                                             |
| A0000 | AFFFF | 64KB             | 用于彩色显示适配器                                                                                                                             |
| 9FC00 | 9FFFF | 1KB              | EBDA（Extern BIOS Data Area）扩展BIOS数据区                                                                                                    |
| 7E00  | 9FBFF | 622080B约为608KB | 可用区域                                                                                                                                       |
| 7C00  | 7DFF  | 512B             | MBR被BIOS加载到此处，共512字节                                                                                                                 |
| 500   | 7BFF  | 30464B约30KB     | 可用区域                                                                                                                                       |
| 400   | 4FF   | 256B             | BIOS Data Area                                                                                                                                 |
| 000   | 3FF   | 1KB              | Interrupt vector Table 中断向量表                                                                                                              |





 `DW 0XAA55`     是一个魔数,用来表示这是一个可引导扇区，如果不是这个内容，就不会读取加载（this is not system disk）








| 寄存器| 表示 |
| :--:| :--: |
| cs| 代码段  |
| ds| 数据段  |
| ss| 栈段  |
| es| 附加段  |
| fs| 附加段  |
| gs| 附加段  |


惯用法： cx 用作循环次数控制，bx存储起始位置 si，(esi) , esi 寄存器作为复制指令的源地址，edi为目的地址





# 实模式下 用汇编显示文字


AX――累加器（Accumulator），使用频度最高  
BX――基址[寄存器](https://so.csdn.net/so/search?q=%E5%AF%84%E5%AD%98%E5%99%A8&spm=1001.2101.3001.7020)（Base Register），常存放存储器地址  
CX――计数器（Count Register），常作为计数器  
DX――数据寄存器（Data Register），存放数据  
SI――源变址寄存器（Source Index），常保存[存储单元](https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83&spm=1001.2101.3001.7020)地址  
DI――目的变址寄存器（Destination Index），常保存存储单元地址  
BP――基址指针寄存器（Base Pointer），表示堆栈区域中的基地址  
SP――堆栈指针寄存器（Stack Pointer），指示堆栈区域的栈顶地址  
IP――指令指针寄存器（Instruction Pointer），指示要执行指令所在存储单元的地址。IP寄存器是一个专用寄存器。





## 寻址的几种方式

1. 立即数寻址
2. 内存寻址
3. 基址寻址，（用bx寄存器作为地址的开始）
   - bp的寄存器默认是寄存ss,所以 bp和sp都是栈的有效地址
   - sp 是 栈中的数据游标 （push 和 pop都是看sp的，不能随便乱动这个值）
   - 我们可以理解为是sp是链表头指针，不能乱动, bp相当于栈指针，用bp就是操作栈



EBP和ESP都是汇编中关于指针的寄存器。但是定义不同：

（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。
（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。

也就是说ESP是栈顶指针，EBP是取堆栈指针。

其中上面提到了一个栈帧的概念，百度百科的解释为“过程活动记录，是编译器用来实现函数调用的一种数据结构”。也可以说是对一次函数调用时记录相关信息的单元。而栈则存储了多个栈帧，也就是说存储了多个函数调用的记录单元。

其中函数调用的完整过程为：函数调用前，EBP的值入栈，ESP存储的是栈顶地址。然后ESP的值传给EBP，函数被调用，此时ESP一直指向栈顶。函数调用结束后，EBP将值传回ESP，ESP又指向了栈顶地址。


```asm

;esp和ebp的在函数调用时的行为

;让esp指向当前的栈底
mov esp,ebp ;让esp指向当前的栈底
pop ebp ;将栈顶(esp指向的内存)的值给ebp这样，就恢复了上个函数调用此函数至少得值，esp因为弹栈而加四，然后指向的是返回地址。
; [e] 是扩展，bp 

```


https://www.cnblogs.com/xiangtingshen/p/11221277.html




## 保护模式是什么？


1. 寄存器在段式内存中，其实没有界限，操作系统和用户程序实际做不到内存的隔离。
2. 用户程序所访问的逻辑地址实际上就是物理地址
3. 用户程序可以随意修改段基址 (mbr, es=7c00,loader=b800)

不能让用户程序随意修改内存，内存地址

看看寄存器扩展：(保护模式：将16位寄存器，扩展到32位)



为了 实现32位的寻址，intel专门设计了一个数据结构描述这个寻址，全局描述符表GDT

由于这是一个复杂的数据结构，放在内存中。




## 专门存一些要用的数据？ 寄存器只有这么点，够用吗？

```asm
mov cx,0x8000
push ds ; ds 的寄存器值入栈，到时候出栈就可以恢复ds了，可以暂存了 数据段
mov ds,cx ; cx赋值给 ds
mov [0x03],dx


```





